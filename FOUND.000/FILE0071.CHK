ty = numpy.asarray(im)

        data = intensity.astype(numpy.uint8)
        mask = data.tobytes()  # serialise

        # do the openGL binding
        if self.interpolate:
            smoothing = GL.GL_LINEAR
        else:
            smoothing = GL.GL_NEAREST
        GL.glBindTexture(GL.GL_TEXTURE_1D, self._maskID)
        GL.glTexImage1D(GL.GL_TEXTURE_1D, 0, GL.GL_ALPHA,
                        res, 0, GL.GL_ALPHA, GL.GL_UNSIGNED_BYTE, mask)
        # makes the texture map wrap (this is actually default anyway)
        GL.glTexParameteri(GL.GL_TEXTURE_1D, GL.GL_TEXTURE_WRAP_S,
                           GL.GL_CLAMP_TO_EDGE)
        # linear smoothing if texture is stretched
        GL.glTexParameteri(GL.GL_TEXTURE_1D, GL.GL_TEXTURE_MAG_FILTER,
                           smoothing)
        GL.glTexParameteri(GL.GL_TEXTURE_1D, GL.GL_TEXTURE_MIN_FILTER,
                           smoothing)
        GL.glTexEnvi(GL.GL_TEXTURE_ENV, GL.GL_TEXTURE_ENV_MODE,
                     GL.GL_MODULATE)
        GL.glEnable(GL.GL_TEXTURE_1D)

        self._needUpdate = True

    def setMask(self, value, log=None):
        """Usually you can use 'stim.attribute = value' syntax instead,
        but use this method if you need to suppress the log message
        """
        setAttribute(self, 'mask', value, log)

    def _setRadialAtribute(self, attr, value):
        """Internal helper function to reduce redundancy
        """

        self.__dict__[attr] = value  # avoid recursing the attributeSetter
        self._updateTextureCoords()
        self._needUpdate = True

    @attributeSetter
    def angularCycles(self, value):
        """Float (but Int is prettiest). Set the number of cycles going
        around the stimulus. i.e. it controls the number of 'spokes'.

        :ref:`Operations <attrib-operations>` supported.
        """
        self._setRadialAtribute('angularCycles', value)

    def setAngularCycles(self, value, operation='', log=None):
        """Usually you can use 'stim.attribute = value' syntax instead,
        but use this method if you need to suppress the log message
        """
        setAttribute(self, 'angularCycles', value, log,
                     operation)  # calls the attributeSetter

    @attributeSetter
    def radialCycles(self, value):
        """Float (but Int is prettiest). Set the number of texture cycles
        from centre to periphery, i.e. it controls the number of 'rings'.

        :ref:`Operations <attrib-operations>` supported.
        """
        self._setRadialAtribute('radialCycles', value)

    def setRadialCycles(self, value, operation='', log=None):
        """Usually you can use 'stim.attribute = value' syntax instead,
        but use this method if you need to suppress the log message
        """
        setAttribute(self, 'radialCycles', value, log,
                     operation)  # calls the attributeSetter

    @attributeSetter
    def angularPhase(self, value):
        """Float. Set the angular phase (like orientation) of the texture
        (wraps 0-1).

        This is akin to setting the orientation of the texture around the
        stimulus in radians. If possible, it is more efficient to rotate the
        stimulus using its `ori` setting instead.

        :ref:`Operations <attrib-operations>` supported.
        """
        self._setRadialAtribute('angularPhase', value)

    def setAngularPhase(self, value, operation='', log=None):
        """Usually you can use 'stim.attribute = value' syntax instead,
        but use this method if you need to suppress the log message
        """
        setAttribute(self, 'angularPhase', value, log,
                     operation)  # calls the attributeSetter

    @attributeSetter
    def radialPhase(self, value):
        """Float. Set the radial phase of the texture (wraps 0-1). This is the
        phase of the texture from the centre to the perimeter of the stimulus
        (in radians). Can be used to drift concentric rings out/inwards.

        :ref:`Operations <attrib-operations>` supported.
        """
        self._setRadialAtribute('radialPhase', value)

    def setRadialPhase(self, value, operation='', log=None):
        """Usually you can use 'stim.attribute = value' syntax instead,
        but use this method if you need to suppress the log message
        """
        setAttribute(self, 'radialPhase', value, log,
                     operation)  # calls the attributeSetter

    def _updateEverything(self):
        """Internal helper function for angularRes and visibleWedge (and init)
        """
        self._triangleWidth = pi * 2 / self.angularRes
        self._angles = numpy.arange(0, pi * 2, self._triangleWidth,
                                    dtype='float64')
        # which vertices are visible?
        # first edge of wedge:
        visW = self.visibleWedge
        self._visible = (self._angles >= visW[0] * pi / 180)
        # second edge of wedge:
        edge2 = (self._angles + self._triangleWidth) * (180/pi) > visW[1]
        self._visible[edge2] = False
        self._nVisible = numpy.sum(self._visible) * 3
        self._updateTextureCoords()
        self._updateMaskCoords()
        self._updateVerticesBase()
        self._updateVertices()  # is this necessary? Works fine without...

    @attributeSetter
    def angularRes(self, value):
        """The number of triangles used to make the sti.

         :ref:`Operations <attrib-operations>` supported."""
        self.__dict__['angularRes'] = value
        self._updateEverything()

    @attributeSetter
    def visibleWedge(self, value):
        """tuple (start, end) in degrees. Determines visible range.

        (0, 360) is full visibility.

        :ref:`Operations <attrib-operations>` supported.
        """
        self.__dict__['visibleWedge'] = numpy.array(value)
        self._updateEverything()

    def draw(self, win=None):
        """Draw the stimulus in its relevant window. You must call
        this method after every `win.flip()` if you want the
        stimulus to appear on that frame and then update the screen
        again.

        If `win` is specified then override the normal window of this
        stimulus.
        """
        if win is None:
            win = self.win
        self._selectWindow(win)

        # do scaling
        GL.glPushMatrix()  # push before the list, pop after
        # scale the viewport to the appropriate size
        self.win.setScale('pix')
        # setup color
        GL.glColor4f(*self._foreColor.render('rgba1'))

        # assign vertex array
        GL.glVertexPointer(2, GL.GL_DOUBLE, 0, self.verticesPix.ctypes)

        # then bind main texture
        GL.glActiveTexture(GL.GL_TEXTURE0)
        GL.glBindTexture(GL.GL_TEXTURE_2D, self._texID)
        GL.glEnable(GL.GL_TEXTURE_2D)
        # and mask
        GL.glActiveTexture(GL.GL_TEXTURE1)
        GL.glBindTexture(GL.GL_TEXTURE_1D, self._maskID)
        GL.glDisable(GL.GL_TEXTURE_2D)
        GL.glEnable(GL.GL_TEXTURE_1D)

        # setup the shaderprogram
        prog = self.win._progSignedTexMask1D
        GL.glUseProgram(prog)
        # set the texture to be texture unit 0
        GL.glUniform1i(GL.glGetUniformLocation(prog, b"texture"), 0)
        # mask is texture unit 1
        GL.glUniform1i(GL.glGetUniformLocation(prog, b"mask"), 1)

        # set pointers to visible textures
        GL.glClientActiveTexture(GL.GL_TEXTURE0)
        GL.glTexCoordPointer(2, GL.GL_DOUBLE, 0,
                             self._visibleTexture.ctypes)
        GL.glEnableClientState(GL.GL_TEXTURE_COORD_ARRAY)

        # mask
        GL.glClientActiveTexture(GL.GL_TEXTURE1)
        GL.glTexCoordPointer(1, GL.GL_DOUBLE, 0,
                             self._visibleMask.ctypes)
        GL.glEnableClientState(GL.GL_TEXTURE_COORD_ARRAY)

        # do the drawing
        GL.glEnableClientState(GL.GL_VERTEX_ARRAY)
        GL.glDrawArrays(GL.GL_TRIANGLES, 0, self._nVisible)

        # unbind the textures
        GL.glClientActiveTexture(GL.GL_TEXTURE1)
        GL.glBindTexture(GL.GL_TEXTURE_2D, 0)
        # main texture
        GL.glClientActiveTexture(GL.GL_TEXTURE0)
        GL.glBindTexture(GL.GL_TEXTURE_2D,